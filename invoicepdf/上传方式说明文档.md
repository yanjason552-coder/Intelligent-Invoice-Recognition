# 发票上传方式说明文档

## 概述

系统提供两种发票上传方式：
1. **本地上传（系统服务器）** - 直接上传到系统服务器
2. **模型配置上传（外部 API）** - 先上传到外部API，再保存到系统服务器

---

## 方式一：本地上传（系统服务器）

### 运行流程

```
用户选择文件
    ↓
前端验证文件（类型、大小）
    ↓
调用后端API: POST /api/v1/invoices/upload
    ↓
后端处理：
  1. 验证文件类型（PDF、JPG、PNG）
  2. 验证文件大小（≤10MB）
  3. 计算文件哈希值（SHA256）
  4. 检查文件是否已存在（基于哈希值）
  5. 生成唯一文件名并保存到本地磁盘
  6. 创建 InvoiceFile 记录
  7. 自动创建 Invoice 记录
    ↓
返回成功消息
```

### 程序逻辑

#### 前端逻辑（InvoiceUpload.tsx）

```typescript
// 上传到本地API
const uploadToLocalAPI = async (fileItem: UploadedFile) => {
  // 1. 获取访问令牌
  const token = localStorage.getItem('access_token')
  
  // 2. 创建 FormData
  const formData = new FormData()
  formData.append('file', fileItem.file)
  
  // 3. 调用后端上传接口
  const response = await axios.post(
    `${apiBaseUrl}/api/v1/invoices/upload`,
    formData,
    {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'multipart/form-data',
      },
      onUploadProgress: (progressEvent) => {
        // 更新上传进度
      }
    }
  )
  
  return response
}
```

#### 后端逻辑（invoice.py）

```python
@router.post("/upload", response_model=Message)
def upload_invoice(
    *,
    session: SessionDep,
    file: UploadFile = File(...),
    current_user: CurrentUser
) -> Any:
    """
    上传票据文件
    """
    # 1. 验证文件类型
    allowed_types = ["application/pdf", "image/jpeg", "image/png", "image/jpg"]
    if file.content_type not in allowed_types:
        raise HTTPException(status_code=400, detail="不支持的文件类型")
    
    # 2. 验证文件大小（10MB）
    file_content = file.file.read()
    file_size = len(file_content)
    if file_size > 10 * 1024 * 1024:
        raise HTTPException(status_code=400, detail="文件大小不能超过 10MB")
    
    # 3. 计算文件哈希值
    file_hash = hashlib.sha256(file_content).hexdigest()
    
    # 4. 检查文件是否已存在
    existing_file = session.exec(
        select(InvoiceFile).where(InvoiceFile.file_hash == file_hash)
    ).first()
    if existing_file:
        raise HTTPException(status_code=400, detail="文件已上传过")
    
    # 5. 生成唯一文件名并保存
    unique_filename = f"{uuid4()}{file_ext}"
    file_path = UPLOAD_DIR / unique_filename
    with open(file_path, "wb") as buffer:
        shutil.copyfileobj(file.file, buffer)
    
    # 6. 创建文件记录
    invoice_file = InvoiceFile(
        file_name=file.filename,
        file_path=str(file_path),
        file_size=file_size,
        file_type=file_ext[1:],
        mime_type=file.content_type,
        file_hash=file_hash,
        uploader_id=current_user.id,
        status="uploaded"
        # 注意：external_file_id 为 None
    )
    session.add(invoice_file)
    session.commit()
    
    # 7. 自动创建票据记录
    invoice = Invoice(
        invoice_no=f"INV-{datetime.now().strftime('%Y%m%d%H%M%S')}-{str(uuid4())[:8]}",
        invoice_type="未知",
        file_id=invoice_file.id,
        creator_id=current_user.id,
        recognition_status="pending",
        review_status="pending"
    )
    session.add(invoice)
    session.commit()
    
    return Message(message=f"文件上传成功，票据编号: {invoice.invoice_no}")
```

### 特点

- ✅ **简单直接**：一步完成上传
- ✅ **速度快**：直接保存到本地服务器
- ✅ **无外部依赖**：不依赖外部API服务
- ❌ **无外部文件ID**：`InvoiceFile.external_file_id` 为 `None`

---

## 方式二：模型配置上传（外部 API）

### 运行流程

```
用户选择文件
    ↓
用户选择模型配置（LLMConfig）
    ↓
前端验证文件（类型、大小）
    ↓
第一步：调用外部API上传
  POST {config.endpoint}/files/upload
  参数：file, user
  认证：Bearer {config.api_key}
    ↓
外部API返回：{ id: "external_file_id" }
    ↓
第二步：调用后端API保存文件信息
  POST /api/v1/invoices/upload-external
  参数：file, external_file_id
    ↓
后端处理：
  1. 验证文件类型和大小
  2. 计算文件哈希值
  3. 检查文件是否已存在
  4. 保存文件到本地磁盘
  5. 创建 InvoiceFile 记录（包含 external_file_id）
  6. 自动创建 Invoice 记录
    ↓
返回成功消息（包含外部文件ID）
```

### 程序逻辑

#### 前端逻辑（InvoiceUpload.tsx）

```typescript
// 上传到模型API（外部API）
const uploadToModelAPI = async (fileItem: UploadedFile, config: LLMConfig) => {
  // 第一步：上传到外部API
  const externalEndpoint = config.endpoint.endsWith('/') 
    ? config.endpoint.slice(0, -1) 
    : config.endpoint
  const uploadUrl = `${externalEndpoint}/files/upload`
  
  const formData = new FormData()
  formData.append('file', fileItem.file)
  formData.append('user', userName)
  
  // 调用外部API
  const externalResponse = await axios.post(
    uploadUrl,
    formData,
    {
      headers: {
        'Authorization': `Bearer ${config.api_key}`,
        'Content-Type': 'multipart/form-data',
      },
      onUploadProgress: (progressEvent) => {
        // 更新上传进度
      }
    }
  )
  
  // 获取外部API返回的文件ID
  const externalFileId = externalResponse.data?.id
  if (!externalFileId) {
    throw new Error('外部 API 返回数据中缺少 id 字段')
  }
  
  // 第二步：调用后端接口保存文件信息
  const backendFormData = new FormData()
  backendFormData.append('file', fileItem.file)
  backendFormData.append('external_file_id', externalFileId)
  
  const backendResponse = await axios.post(
    `${apiBaseUrl}/api/v1/invoices/upload-external`,
    backendFormData,
    {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'multipart/form-data',
      }
    }
  )
  
  return backendResponse
}
```

#### 后端逻辑（invoice.py）

```python
@router.post("/upload-external", response_model=Message)
def upload_invoice_external(
    *,
    session: SessionDep,
    file: UploadFile = File(...),
    external_file_id: str = Form(...),
    current_user: CurrentUser
) -> Any:
    """
    上传票据文件（从外部API上传后保存到本地数据库）
    用于保存通过模型配置上传到外部API的文件信息
    """
    # 1. 验证外部文件ID
    if not external_file_id:
        raise HTTPException(status_code=400, detail="缺少外部文件ID")
    
    # 2-4. 验证文件类型、大小、哈希值（同本地上传）
    # ...（省略相同逻辑）
    
    # 5. 生成唯一文件名并保存（同本地上传）
    # ...（省略相同逻辑）
    
    # 6. 创建文件记录（包含外部文件ID）
    invoice_file = InvoiceFile(
        file_name=file.filename,
        file_path=str(file_path),
        file_size=file_size,
        file_type=file_ext[1:],
        mime_type=file.content_type,
        file_hash=file_hash,
        uploader_id=current_user.id,
        status="uploaded",
        external_file_id=external_file_id  # ⭐ 关键区别：保存外部API返回的文件ID
    )
    session.add(invoice_file)
    session.commit()
    
    # 7. 自动创建票据记录（同本地上传）
    # ...（省略相同逻辑）
    
    return Message(
        message=f"文件上传成功，票据编号: {invoice.invoice_no}, 外部文件ID: {external_file_id}"
    )
```

### 特点

- ✅ **双重存储**：文件同时存在于外部API和本地服务器
- ✅ **外部文件ID**：`InvoiceFile.external_file_id` 保存外部API返回的ID
- ✅ **可追踪**：可以通过外部文件ID在外部系统中查找文件
- ❌ **依赖外部服务**：需要外部API服务可用
- ❌ **两步操作**：需要先上传到外部API，再保存到本地
- ❌ **速度较慢**：需要两次网络请求

---

## 两种方式的区别对比

| 对比项 | 本地上传 | 模型配置上传 |
|--------|---------|-------------|
| **上传步骤** | 1步：直接上传到后端 | 2步：先上传外部API，再保存到后端 |
| **外部API调用** | ❌ 无 | ✅ 需要调用外部API |
| **外部文件ID** | ❌ `external_file_id = None` | ✅ 保存外部API返回的ID |
| **文件存储位置** | 仅本地服务器 | 外部API + 本地服务器 |
| **速度** | 快 | 较慢（两次请求） |
| **依赖** | 无外部依赖 | 依赖外部API服务 |
| **适用场景** | 普通上传需求 | 需要与外部系统集成的场景 |

---

## 涉及的程序文件

### 前端文件

1. **`frontend/src/components/Invoice/InvoiceUpload.tsx`**
   - 上传组件主文件
   - 包含两种上传方式的UI和逻辑
   - 关键函数：
     - `uploadToLocalAPI()` - 本地上传
     - `uploadToModelAPI()` - 模型配置上传
     - `loadModelConfigs()` - 加载模型配置列表
     - `getModelConfigWithKey()` - 获取模型配置详情

### 后端文件

1. **`backend/app/api/routes/invoice.py`**
   - 发票相关API路由
   - 关键接口：
     - `POST /api/v1/invoices/upload` - 本地上传接口
     - `POST /api/v1/invoices/upload-external` - 外部API上传保存接口

2. **`backend/app/models/models_invoice.py`**
   - 数据模型定义
   - 关键模型：
     - `InvoiceFile` - 文件表（包含 `external_file_id` 字段）
     - `Invoice` - 票据表
     - `LLMConfig` - 大模型配置表

3. **`backend/app/api/routes/config.py`**
   - 配置相关API路由
   - 关键接口：
     - `GET /api/v1/config/llm/list` - 获取模型配置列表
     - `GET /api/v1/config/llm` - 获取默认模型配置

### 配置文件

- **`backend/app/api/routes/invoice.py`** (第33-38行)
  - 定义文件上传目录：`UPLOAD_DIR = BACKEND_DIR / "uploads" / "invoices"`

---

## 操作差异说明

### 用户操作流程差异

#### 本地上传操作：
1. 选择上传方式：**本地上传（系统服务器）**
2. 选择文件（拖拽或点击）
3. 点击"开始上传"
4. ✅ 完成

#### 模型配置上传操作：
1. 选择上传方式：**模型配置上传（外部 API）**
2. **选择模型配置**（从下拉列表中选择）
3. 选择文件（拖拽或点击）
4. 点击"开始上传"
5. 系统先上传到外部API
6. 系统再保存到本地服务器
7. ✅ 完成

### 关键差异点

1. **模型配置选择**
   - 本地上传：无需选择模型配置
   - 模型配置上传：必须选择一个模型配置（LLMConfig）

2. **网络请求次数**
   - 本地上传：1次请求（仅后端API）
   - 模型配置上传：2次请求（外部API + 后端API）

3. **数据存储**
   - 本地上传：仅本地数据库和文件系统
   - 模型配置上传：外部API + 本地数据库和文件系统

4. **错误处理**
   - 本地上传：只需处理后端错误
   - 模型配置上传：需要处理外部API错误和后端错误

---

## 数据库字段差异

### InvoiceFile 表

两种方式创建的 `InvoiceFile` 记录主要区别在于 `external_file_id` 字段：

- **本地上传**：`external_file_id = NULL
- **模型配置上传**：`external_file_id = "外部API返回的文件ID"`

其他字段（文件名、路径、大小、哈希值等）完全相同。

---

## 总结

两种上传方式的核心区别在于：

1. **本地上传**：简单直接，一步完成，适合普通使用场景
2. **模型配置上传**：先上传到外部API，再保存到本地，适合需要与外部系统集成的场景

两种方式最终都会在本地服务器保存文件并创建数据库记录，但模型配置上传方式会额外保存外部文件ID，便于后续与外部系统进行关联和追踪。





